1、编写高质量代码：要扩展性高，能够应对变化，同时可读性好，应为代码被读的次数很多。

![image-20200518085141100](C:\Users\30753\AppData\Roaming\Typora\typora-user-images\image-20200518085141100.png)



2、七大原则：要分清代码的作者和用户，作者可以简单理解为服务端、用户就是客户端。当作为作者时，这些原则在编写代码时是很重要的，写得不好，用户（别人）可能用都用不了。

* 单一职责原则：一个类只做一种事，一个方法只做一件事（SOLID之S，Single Resopsibility Princeple）

* 开闭原则： 对扩展开放，对修改关闭 （SOLID之O， Open Closed Principle ）
* 里氏替换原则： 所有引用基类的地方必须能透明地使用其子类的对象 。（SOLID之L， Liskov Substitution Principle ）
  * 也就是说在任何使用父类引用的地方，将父类替换成子类，语法不会报错，**业务逻辑也不会出问题**。
  * 通过继承，有Java的语法约束，应该不会有问题，要保证业务逻辑正确，也就是子类在继承父类时，不要覆盖（**重写**）父类的方法。
  * 里氏替换原则是继承复用的基石，所以应该说是Java继承的语法是根据这个原则定义的：
    * 子类继承父类时，方法应该有不低于父类的访问权限
    * 子类继承父类时，方法不能抛出比父类更多的异常
* 迪米特法则：又叫作最少知道原则，只与你的直接朋友交谈，不跟“陌生人”说话。（ SOLID之L，Law of Demeter：迪米特法则 ）
  * 最小知道：一个类不应该将太多内部信息让外界知道，也就是要封装。譬如不是类的所有属性都需要添加getter和setter
  * “朋友”：对象本身this、类字段、方法的参数、方法内new的局部变量、返回值等都是朋友。
  * 也就是说如果两个软件实体**无须直接通信**，那么就不应当发生**直接的相互调用**，可以通过第三方**转发该调用**。（ SOLID之L，Law of Demeter：迪米特法则 ）
* 接口隔离原则：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。（SOLID之I，Interface Segregation Principle）
* 依赖倒置原则：上层不能依赖于下层，它们都应该依赖于抽象。依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，也就是面向接口而不是面向实现来编程（SOLID之D，Dependence Inversion Principle）
  * 上层：调用别人方法的，就是上层
  * 下层：被调用的方法，就属于下层
  * 这也是要多设计接口的原因吧，服务端在实现代码时，利用接口，客户端在使用时，调用服务端处理时，可以先面向接口，做一个自己的实现，然后将这个实现作为入参传递进去
* 组合优与继承：尽量使用组合/聚合的方式，而不是使用继承。



3、根据类与类之间的耦合度从弱到强排列，UML 中的**类图**（UML有多种图）有以下几种关系：

* 依赖关系：虚线+箭头
* 关联关系：老师-学生，一个老师有多个学生，一个学生有多个老师，在代码中就是`Teacher`类中有`List<Student> students`属性、`Student`类中有`List<Teacher>`属性（实线+箭头）
* 聚合关系(has-a)：学校里面有教师，`University`类中有`List<Teacher>`属性，成员对象可以脱离整体对象而独立存在。（虚的菱形+实线）
* 组合关系(contains-a)：`Head`类中有`Mouth`，一旦整体对象不存在，部分对象也将不存在。（实的菱形+箭头）
  * 关联、聚合、组合都是一个类作为另一个类的属性，依赖可能更接近与局部变量。具体的区别，处理聚合之外，关联和组合更重要的是语义的区分
* 泛化关系(is-a)：三角+实线
* 实现关系：三角+虚线
* 除了最后一组外，变实了可以对应耦合关系增强



4、



5、单例模式（还有静态内部类和枚举类的方法就不看了）：因为要确保只有一次实例，所以该实例对象与类绑定，代码上就是说要是`static`的。

* 饿汉式：不存在线程安全问题，缺点是浪费内存，**没有懒加载**。可以使用。
  * 无参构造方法私有化
  * `INSTANCE`是<font color="red">`static final`的</font>，并且在声明的时候就创建对像
    * 类加载的时候是不会有线程安全问题
  * 饿汉式实例对象的创建可以：(1)在声明的时候；(2)在静态代码块中。
* 懒汉式：懒加载，但是不能保证线程安全。要么性能差（把整个方法都同步）、要么有线程安全问题，不建议使用。

* 双重校验锁（是可用的、高性能的懒汉式）
  * 属性是<font color="red">`static volatile`</font>，确保可见性
  * 在`synchronized`同步代码块中**还需要判断一次**
* **静态内部**类方式：私有的静态内部类，并且只有一个静态的`Singleton`类型的熟悉
  * **类在第一次使用的时候才加载**
  * 类加载的时候是不会有线程安全问题
  * 外部类加载时，静态内部类不会被加载（实现懒加载）
* 枚举类：既是一个`class`，又有更多的约束。
  * 使用是可以看到`Singleton.INSTANCE`的变量类型依然是`Singleton`

```java
public class SingletonTest08 {
	public static void main(String[] args) {
		Singleton instance = Singleton.INSTANCE;
		Singleton instance2 = Singleton.INSTANCE;
		System.out.println(instance == instance2);
		
		System.out.println(instance.hashCode());
		System.out.println(instance2.hashCode());
		
		instance.sayOK();
	}
}

//使用枚举，可以实现单例, 推荐
enum Singleton {
	INSTANCE; //属性
	public void sayOK() {
		System.out.println("ok~");
	}
}
```

* 单例模式的经典英语：jdk中的`Runtime`类就是采用的饿汉式的单例模式。



5.1、题外。

* `final`类型的**属性**的赋值：确保在使用之前要初始化，不是针对某一对象实例使用之前，而是**该类对象**使用之前。所以必须在以下地方完成初始化：
  * 可以在创建是赋值
  * 可以在构造方法中赋值
    * 如果有无参构造方法，必须在无参构造方法里（因为无参构造方法肯定**会最先执行**）
    * 没有无参构造器，只有**一个**有参构造器，也可以在这个有参构造器中完成初始化
    * 多有有参构造器，则**不能**在构造方法中初始化（因为不能确定是哪个会被调用，也就无法保证在用之前完成初始化）
  * 即使有构造方法，也可以在构造块中赋值（因为构造块早于构造方法执行）
  * 但不能在静态代码块中赋值，<font color="red">因为`static`修饰里面不能有非静态的（临时变量，也就是内部声明的变量除外）</font>
  * `static final`可以在静态代码块中赋值，但**不能在构造方法**中初始化，也不能在构造块中执行，因为类加载先于构造方法执行
  * 这也是为什么饿汉式定义成`static final`，懒汉式定义成`static`不能有`final`
* 内部类和静态内部类都是延时加载的。
  * 静态内部类**首先是类**，只有在使用是才会加载，这是与变量和静态代码块的不同
* <font color="red">**静态块、构造块、构造方法的执行顺序**</font>
  * 从高赞答案中总结如下：（这个题可以作为类加载的过程来了解）
    * 1、**开始时JVM加载B.class**，对所有的静态成员进行声明，**t1 t2（同时）被初始化为默认值，为null**。
    * 2、因为t1 t2需要被显式初始化(new)，所以对t1进行显式初始化，初始化代码块→构造函数（没有就是调用默认的构造函数），在初始化t1时也不会再执行static块了，因为JVM认为这是第二次加载类B了。
    * 3、同理对t2的加载（不会再有加载类的过程，这一直是在执行一次类加载的任务。）
    * 4、对所有的static变量都完成了初始化，接着就执行static块部分（输出'静态块'）。
    * 5、在方法中，前面已经完成了静态变量和静态块的加载，不会再加载，但是会执行代码块
  * 静态的肯定会先于构造块（或者成为普通代码块），但这与答案并不违背，因为它首先就是去加载`t1`这个静态对象去了
    * 如果是`public B t1 = new B()`就会报错`StackOverflowError`，因为<font color="red">它不是静态的</font>，会一直递归调用

![image-20200421142411718](C:\Users\30753\AppData\Roaming\Typora\typora-user-images\image-20200421142411718.png)





6、简单工厂模式。

* 简单工厂里的概念：抽象产品、具体产品、产品工厂（还没有产品簇的概念）
* 优点：能把具体的产品从客户端的代码解耦出来，按照自己写的那个例子，就是当Hamburger类或者Steak类变化时，工厂方法随之变换。但是对应的客户端的代码不需要发生改变。
* 缺点：
  * 客户端必须记忆与key常量（可以是int类型，也可以是其它类型）与具体产品的对应关系
  * 当具体类特别多时，简单工厂代码会变得非常复杂
  * 不能应对产品的**变化**：但客户端需要扩展产品时，无法加到工厂里面去



7、工厂方法：核心是把创建对象的时机推迟到子类。

* 工厂方法概念：还是没有产品簇的概念
* 优点：
  * 任然具有简单工厂的所有优点
  * 对于简单工厂的缺点——客户端需要扩展时，工厂方法可以直接扩展出一个产品簇的工厂出来
* 杠点：
  * 客户端依旧依赖于具体工厂，当具体工厂发生变化时，客户单也要跟着变，这是不是又变成了原来的问题？
    * 解答：并不是，工厂类是直接被视为接口的（interface是语法的接口，在设计上，所有对外暴露的都应该被设为接口），对于接口，作者有义务维护它保持不变。或者改变的概率远低于产品改变的概率
  * 既然产品时自己实现的（Salad类），为什么还要创建一个工厂类（SaladFactory）？
    * 解答：因为开发功能时，不仅仅是抽象产品、具体产品、抽象工厂、具体工厂，还会为一些业务提供框架支持。像例子中就是Business类的业务，它都是面向工厂的
* 缺点：产品类别多的时候，工厂方法需要的类会爆炸



8、抽象工厂。

* 抽象工厂概念：

  * 产品簇：多个有内在联系，或者有逻辑关系的产品
  * 产品等级：

  <img src="C:\Users\30753\AppData\Roaming\Typora\typora-user-images\image-20200521145303849.png" alt="image-20200521145303849" style="zoom:80%;" />

* 优点：对于产品簇（有内在联系的产品），使用抽象工厂能比工厂方法少很多方法。但同时具有能把客户端与具体的产品解耦的能力。

* 杠点：

  * 抽象工厂获得单个产品感觉怪怪的？
    * 解答：这TM不是它怪，而是场景不合适，**设计模式没有好坏之分，是与具体场景对应的**

* 缺点：当扩展了产品等级之后，所有的具体工厂的代码都要修改



9、原型模式：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。。

* 浅克隆：对于基本数据类型的成员变量，浅拷贝直接进行**值传递**，对象类型则是会将成员变量的引用复制给新的对象，因此这两个对象的该成员变量**有相同的引用**，一个对象对该成员变量进行修改会影响到另个一个对象的该成员变量值。
  * 而String类型变量，则因为String变量的唯一性，即使一个对象中对该成员变量进行修改，也不会对另一个成员变量产生影响。
* 深克隆：深拷贝会对对象的所有成员变量，包括对象类型的成员变量都会重新开辟内存空间。
* 实现深克隆有两种办法：
  * 一种是原型类实现`Cloneable`接口，重写clone()方法，在方法中先调用**super.clone()方法克隆出一个新对象来**，然后**手动**给克隆出来的对象**赋值**；
  * 另一种就是将原型类实现序列化接口`Seriazible`，通过`ObjectOutputStream`的`writeObject()`方法转成输出流（不一定要写出去），然后通过`ObjectInputStream`的`readObject()`方法反序列化得到对象实例。



10、建造者模式。

* 概念：建造者和指挥者
  * 建造者用来规范流程，**稳定建造过程**（接口就是规范，方法必须被实现）
  * 指挥者执行这些规范，并返回建造的对象
* 与简单工厂、工厂方法、抽象工厂的区别？
  * 这些模式返回了一个新创建的对象，但是这个对象并没有被赋值。而建造者模式需要返回一个构建好的对象实例。

* 应对改变：自己的Builder照样可以用作者（Director类）的代码



11、装饰器模式：装饰器类不仅要继承原有类，同时还要关联原有类，也就是说装饰器类还有一个原有类的属性。

* 自己实现小结（有一部分属于java基础知识）：
  * Bervage是一个抽象类，所有的具体咖啡类Decaf、Espresso等都继承该类，并实现抽象方法，在抽象方法里面写上具体的描述和价格
    * 因为 Bervage 没有无参构造器，无论Decaf、Espresso等是无参构造器还是有参构造器，第一行应该首先调用`super("")`的有参构造器，否则会报错
  * Condiment是所有具体装饰器的父类，它继承了Bervage类，并关联了该类。同时它也是个抽象类。
  * 像Mild、Mocha这些具体装饰类继承Condiment类
  * Condiment中的Bervage属性应该是子类可以访问到的，所有访问权限是`protected`

* jdk中的流就是装饰器模式的使用，像`BufferInputStream`就是一个装饰器，而`FileInputStream`则是原有类
  * 实际上`BufferInputStream`相当于下图中的Milk，而不是Condiment。`BufferInputStream`它继承了`FilterInputStream`，它才是Condiment。所以如果我们想要扩展“调料”来对流进行操作，应该继承`FilterInputStream`
  * `FileInputStream`更接近与Decaf这一级

![image-20200522110050493](C:\Users\30753\AppData\Roaming\Typora\typora-user-images\image-20200522110050493.png)



12、模板方法。

* 合格里面就只有抽象类，没有接口了。
* 这个模式就是要封装固定的部分（执行步骤），**变**的部分应当被设计成接口或者抽象方法
* 以写的那个为例：
  * `calculate()`方法是个具体方法，固化执行步骤
  * `code()`方法就是变的部分，设计成抽象方法
  * java基础知识
    * 在AppTest当中创建了一个`Template1`类的实例，使用父类接的应用。在使用是调用的方法至于new的对象的类型有关，所以调用`calculate()`方法时，调用的是子类的该方法
    * 子类没有重写该方法，所以调用父类的该方法，但是`code()`方法子类重写了。即使`calculate()`方法是在父类中，实例对象依然是子类，所以调用的是子类的`code()`方法
* 我可以用**模板方法来做在线编译的那个执行时间和消耗内存的计算**。



13、代码在重复，重复就是噩梦的开始。创建类型过多，也是噩梦。

进行代码编辑，就要想着应对变化，只要是这个类的朋友可能引起的变化，都要考虑进来。



14、适配器模式：适配器将接收所拥有的的接口，然后产生需要的接口（适配器和需要的接口都属于客户端代码，而拥有的就是别人提供的了）。

* 生活中的适配器：电源适配器。

* 类关系：适配器应当实现“拥有的接口类型”（别人提供的），并且关联“当前的接口类型”（有这个属性）。<font color="red">这个“当前的接口类型“也是已经存在的，否则自己就可以直接实现原接口”</font>使用的时候就是将需要的接口类型作为参数传递给适配器，适配器实现了“拥有的接口”，所以可以适用**配套给“拥有的接口”的Business（业务）**

* 其实适配器的目的**主要是让当前的业务需要使用Business处理逻辑**，所以需要将自己的“当前的接口”适配到“拥有的接口类型”（可以把Business想得更复杂一些）

* java基础知识

  * 返回类型的协变：子类覆盖（重写）基类的方法时，返回的类型可以是基类方法中**返回类型的子类**。这个特性是从jdk1.5开始支持。
  * `result`对象是Object类，它当然是没有`toUpperCase()`方法，所以直接调用`result.toUpperCase()`会出错。即使`(String) result.toUppercase()`也会出错。因为`.`运算符的优先级更高，因此需要使用小括号来提高类型转换的优先级`((String) result).toUpperCase()`
  * 下面那段代码是实现id自增长：因为类只在一次，所以静态属性`counter`只加载一次，`id`是`final int`类型，但不是`static final`类型，所以每创建一个对象，都会重新加载一次，对于对象实例而言，它的`id`属性是不可再变的。`counter`一直在自增。

  ```java
  class Test {
      private static long counter;
      private final long id = counter++;
  }
  ```





15、策略模式：策略模式是指对象有某个行为（**一个**），但是在不同的场景下，该行为有着不同的实现算法。

* 实现Comparator接口，就实现了多种排序策略
* 可以看出类的依赖关系：抽象策略、具体实现策略、环境类，该环境类与抽象策略有关联关系。
* 策略最重要的一点就是**可以在运行时替换**。
  * 如果从这一点来说，TreeSet和TreeMap是不能算作策略模式的，因为它在构造器中传入了Comparator，后面是不能修改的。这两类也确实，因为它是在添加元素是就要排序，所以必须固定。
  * 而LinkedList等其它集合框架就是真正的在运行时可以替换了，这些类的`sort()`方法，在运行时可以随时传入Comparator排序策略



16、责任链模式。

* 变化：客户端要能创建自己的Filter，能同时使用提供的Filter，要经过多个Filter处理。
* 类关系：**Filter接口，自己的Filter实现该接口；FilterChain聚合Filter**。处理之外，类似于SpringMVC或者Servlet中filter的处理，“req顺序、res逆序”，Filter还需要持有FilterChain，请求的时候让下一个过滤器能继续处理。**因此Filter依赖于FilterChain**（它不必持有FilterChain，也就是关联关系，只需要`doFilter()`中有这个参数）。
* 更重要的是Filter的`doFilter(Request req, Response res, FilterChain chain)`。因为像Servlet的FilterChain就是先把req按着Filter顺序处理完，然后将res按着Filter的逆序处理。**整个就是递归的过程。**



17、观察者模式：也称为发布-订阅模式，事件处理模型。

* 应当抽象出一个事件类，可以更详细描述地事件。除此之外，还有一个产生事件`fireEvent`的类，称为事件源。还有一个观察者类，它根据事件来做出响应。
  * 观察者Observer也可以说是Listener
* 类关系：事件源和观察者类都仅仅是依赖于事件类，事件源应当**聚合**观察者类，一旦有事件发生，会通知所有观察者，观察者并不需要依赖或关联事件源类，它是面向事件的。
  * **回调函数(callback function)其实可以理解为就是观察者，因为在聚合时，我的观察者可以匿名内部类，而匿名内部类写成lambda表达式就是我们常见的形式了**。
  * 小结观察者：它可以被称为Observer、Listener、callback function、hook function
* 不过有些时候，在处理事件时可能会比较关心事件源对象，因为一个观察者可能监听多个事件源（观察者被添加到多个主题了），因此事件对象就应当**关联**时间源对象，这个观察者就能通过Event获得事件源。
* 变化：事件源可能是自己定义的类，事件同样是这样，观察者同样会对同一事件有不同的处理方式。所以这三类都是可能被其它人使用或者扩展的。



18、代理模式：主要就是增强类的功能。

* 类关系：代理类必须实现抽象主题接口，同时和具体主题是关联关系。



